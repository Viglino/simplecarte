/* FileSaver.js
 *  A saveAs() & saveTextAs() FileSaver implementation.
 *  2014-06-24
 *
 *  Modify by Brian Chen
 *  Author: Eli Grey, http://eligrey.com
 *  License: X11/MIT
 *    See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */
/* ! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var FileSaver = {}; FileSaver.saveAs=function(e) {
   'use strict'; if ('undefined'==typeof navigator||!/MSIE [1-9]\./.test(navigator.userAgent)) {
      var t=e.document; var n=function() {
         return e.URL||e.webkitURL||e;
      }; var o=t.createElementNS('http://www.w3.org/1999/xhtml', 'a'); var r='download'in o; var i=function(e) {
         var t=new MouseEvent('click'); e.dispatchEvent(t);
      }; var a=/Version\/[\d\.]+.*Safari/.test(navigator.userAgent); var c=e.webkitRequestFileSystem; var d=e.requestFileSystem||c||e.mozRequestFileSystem; var u=function(t) {
         (e.setImmediate||e.setTimeout)(function() {
            throw t;
         }, 0);
      }; var s='application/octet-stream'; var f=0; var l=4e4; var v=function(e) {
         var t=function() {
            'string'==typeof e?n().revokeObjectURL(e):e.remove();
         }; setTimeout(t, l);
      }; var p=function(e, t, n) {
         t=[].concat(t); for (var o=t.length; o--;) {
            var r=e['on'+t[o]]; if ('function'==typeof r) {
               try {
                  r.call(e, n||e);
               } catch (i) {
                  u(i);
               }
            }
         }
      }; var w=function(e) {
         return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)?new Blob(['\uFEFF', e], {type: e.type}):e;
      }; var y=function(t, u, l) {
         l||(t=w(t)); var y; var m; var S; var h=this; var R=t.type; var O=!1; var g=function() {
            p(h, 'writestart progress write writeend'.split(' '));
         }; var b=function() {
            if (m&&a&&'undefined'!=typeof FileReader) {
               var o=new FileReader; return o.onloadend=function() {
                  var e=o.result; m.location.href='data:attachment/file'+e.slice(e.search(/[,;]/)), h.readyState=h.DONE, g();
               }, o.readAsDataURL(t), void(h.readyState=h.INIT);
            } if ((O||!y)&&(y=n().createObjectURL(t)), m)m.location.href=y; else {
               var r=e.open(y, '_blank'); void 0===r&&a&&(e.location.href=y);
            }h.readyState=h.DONE, g(), v(y);
         }; var E=function(e) {
            return function() {
               return h.readyState!==h.DONE?e.apply(this, arguments):void 0;
            };
         }; var N={create: !0, exclusive: !1}; return h.readyState=h.INIT, u||(u='download'), r?(y=n().createObjectURL(t), void setTimeout(function() {
            o.href=y, o.download=u, i(o), g(), v(y), h.readyState=h.DONE;
         })):(e.chrome&&R&&R!==s&&(S=t.slice||t.webkitSlice, t=S.call(t, 0, t.size, s), O=!0), c&&'download'!==u&&(u+='.download'), (R===s||c)&&(m=e), d?(f+=t.size, void d(e.TEMPORARY, f, E(function(e) {
            e.root.getDirectory('saved', N, E(function(e) {
               var n=function() {
                  e.getFile(u, N, E(function(e) {
                     e.createWriter(E(function(n) {
                        n.onwriteend=function(t) {
                           m.location.href=e.toURL(), h.readyState=h.DONE, p(h, 'writeend', t), v(e);
                        }, n.onerror=function() {
                           var e=n.error; e.code!==e.ABORT_ERR&&b();
                        }, 'writestart progress write abort'.split(' ').forEach(function(e) {
                           n['on'+e]=h['on'+e];
                        }), n.write(t), h.abort=function() {
                           n.abort(), h.readyState=h.DONE;
                        }, h.readyState=h.WRITING;
                     }), b);
                  }), b);
               }; e.getFile(u, {create: !1}, E(function(e) {
                  e.remove(), n();
               }), E(function(e) {
                  e.code===e.NOT_FOUND_ERR?n():b();
               }));
            }), b);
         }), b)):void b());
      }; var m=y.prototype; var S=function(e, t, n) {
         return new y(e, t, n);
      }; return 'undefined'!=typeof navigator&&navigator.msSaveOrOpenBlob?function(e, t, n) {
         return n||(e=w(e)), navigator.msSaveOrOpenBlob(e, t||'download');
      }:(m.abort=function() {
         var e=this; e.readyState=e.DONE, p(e, 'abort');
      }, m.readyState=m.INIT=0, m.WRITING=1, m.DONE=2, m.error=m.onwritestart=m.onprogress=m.onwrite=m.onabort=m.onerror=m.onwriteend=null, S);
   }
}('undefined'!=typeof self&&self||'undefined'!=typeof window&&window||this.content); 'undefined'!=typeof module&&module.exports?module.exports.saveAs=saveAs:'undefined'!=typeof define&&null!==define&&null!==define.amd&&define([], function() {
   return saveAs;
});

/* canvas-toBlob.js
 * A canvas.toBlob() implementation.
 * 2016-05-26
 *
 * By Eli Grey, http://eligrey.com and Devin Samarin, https://github.com/eboyjr
 * License: MIT
 *   See https://github.com/eligrey/canvas-toBlob.js/blob/master/LICENSE.md
 */
/* ! @source http://purl.eligrey.com/github/canvas-toBlob.js/blob/master/canvas-toBlob.js */

(function(view) {
   'use strict';
   var
	  Uint8Array = view.Uint8Array;


   var HTMLCanvasElement = view.HTMLCanvasElement;


   var canvas_proto = HTMLCanvasElement && HTMLCanvasElement.prototype;


   var is_base64_regex = /\s*;\s*base64\s*(?:;|$)/i;


   var to_data_url = 'toDataURL'
      ; var base64_ranks;


   var decode_base64 = function(base64) {
      var
			  len = base64.length;


      var buffer = new Uint8Array(len / 4 * 3 | 0);


      var i = 0;


      var outptr = 0;


      var last = [0, 0];


      var state = 0;


      var save = 0;


      var rank;


      var code;


      var undef
		;
      while (len--) {
         code = base64.charCodeAt(i++);
         rank = base64_ranks[code-43];
         if (rank !== 255 && rank !== undef) {
            last[1] = last[0];
            last[0] = code;
            save = (save << 6) | rank;
            state++;
            if (state === 4) {
               buffer[outptr++] = save >>> 16;
               if (last[1] !== 61 /* padding character */) {
                  buffer[outptr++] = save >>> 8;
               }
               if (last[0] !== 61 /* padding character */) {
                  buffer[outptr++] = save;
               }
               state = 0;
            }
         }
      }
      // 2/3 chance there's going to be some null bytes at the end, but that
      // doesn't really matter with most image formats.
      // If it somehow matters for you, truncate the buffer up outptr.
      return buffer;
   }
;
   if (Uint8Array) {
      base64_ranks = new Uint8Array([
		  62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1,
		 -1, -1, 0, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
		 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
		 -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
		 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
      ]);
   }
   if (HTMLCanvasElement && (!canvas_proto.toBlob || !canvas_proto.toBlobHD)) {
      if (!canvas_proto.toBlob) {
         canvas_proto.toBlob = function(callback, type /* , ...args*/) {
		  if (!type) {
               type = 'image/png';
            } if (this.mozGetAsFile) {
               callback(this.mozGetAsFile('canvas', type));
               return;
            } if (this.msToBlob && /^\s*image\/png\s*(?:$|;)/i.test(type)) {
               callback(this.msToBlob());
               return;
            }

            var
			  args = Array.prototype.slice.call(arguments, 1);


            var dataURI = this[to_data_url].apply(this, args);


            var header_end = dataURI.indexOf(',');


            var data = dataURI.substring(header_end + 1);


            var is_base64 = is_base64_regex.test(dataURI.substring(0, header_end));


            var blob
		;
            if (Blob.fake) {
            // no reason to decode a data: URI that's just going to become a data URI again
               blob = new Blob;
               if (is_base64) {
                  blob.encoding = 'base64';
               } else {
                  blob.encoding = 'URI';
               }
               blob.data = data;
               blob.size = data.length;
            } else if (Uint8Array) {
               if (is_base64) {
                  blob = new Blob([decode_base64(data)], {type: type});
               } else {
                  blob = new Blob([decodeURIComponent(data)], {type: type});
               }
            }
            callback(blob);
         };
      }

      if (!canvas_proto.toBlobHD && canvas_proto.toDataURLHD) {
         canvas_proto.toBlobHD = function() {
            to_data_url = 'toDataURLHD';
            var blob = this.toBlob();
            to_data_url = 'toDataURL';
            return blob;
         };
      } else {
         canvas_proto.toBlobHD = canvas_proto.toBlob;
      }
   }
}(typeof self !== 'undefined' && self || typeof window !== 'undefined' && window || this.content || this));
